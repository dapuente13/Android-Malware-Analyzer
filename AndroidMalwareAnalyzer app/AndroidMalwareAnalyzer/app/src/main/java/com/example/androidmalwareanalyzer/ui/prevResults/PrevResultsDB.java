package com.example.androidmalwareanalyzer.ui.prevResults;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.provider.BaseColumns;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public final class PrevResultsDB {

    private static final String SQL_CREATE_ENTRIES =
            "CREATE TABLE " + PrevResultsEntry.TABLE_NAME + " (" +
                    PrevResultsEntry._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
                    PrevResultsEntry.COLUMN_NAME_DATE + " TEXT," +
                    PrevResultsEntry.COLUMN_NAME_ANALYSIS_TYPE + " TEXT," +
                    PrevResultsEntry.COLUMN_NAME_APPS_ANALYSED + " TEXT," +
                    PrevResultsEntry.COLUMN_NAME_ANALYSIS_RESULT + " TEXT)";

    private static final String SQL_DELETE_ENTRIES =
            "DROP TABLE IF EXISTS " + PrevResultsEntry.TABLE_NAME;

    /* Inner class that defines the table contents */
    public static class PrevResultsEntry implements BaseColumns {
        public static final String TABLE_NAME = "prevResults";
        //DATE FORMAT: YYYY-MM-DD HH:MM:SS.SSS
        public static final String COLUMN_NAME_DATE = "date";
        public static final String COLUMN_NAME_ANALYSIS_TYPE = "analysis_type";
        public static final String COLUMN_NAME_APPS_ANALYSED = "apps_analysed";
        public static final String COLUMN_NAME_ANALYSIS_RESULT = "analysis_result";
    }

    /* Inner class that defines the table values */
    public static class PrevResultsValues {
        public long id;
        //date FORMAT: YYYY-MM-DD HH:MM:SS
        public String date;
        public String analysis_type;
        public String apps_analysed;
        public String analysis_result;
    }

    public class PervResultsDbHelper extends SQLiteOpenHelper {
        // If you change the database schema, you must increment the database version.
        public static final int DATABASE_VERSION = 1;
        public static final String DATABASE_NAME = "PrevResults.db";

        public PervResultsDbHelper(Context context) {
            super(context, DATABASE_NAME, null, DATABASE_VERSION);
        }

        public void onCreate(SQLiteDatabase db) {
            db.execSQL(SQL_CREATE_ENTRIES);
        }

        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            db.execSQL(SQL_DELETE_ENTRIES);
            onCreate(db);
        }
    }

    private PervResultsDbHelper dbHelper;

    public PrevResultsDB(Context context) {
        dbHelper = new PervResultsDbHelper(context);
    }

    public long insertToDB(String analysis_type, String strDate, String apps_analysed, String analysis_result) {
        // Gets the data repository in write mode
        SQLiteDatabase db = dbHelper.getWritableDatabase();

        // Create a new map of values, where column names are the keys
        ContentValues values = new ContentValues();
        values.put(PrevResultsEntry.COLUMN_NAME_ANALYSIS_TYPE, analysis_type);
        values.put(PrevResultsEntry.COLUMN_NAME_DATE, strDate);
        values.put(PrevResultsEntry.COLUMN_NAME_APPS_ANALYSED, apps_analysed);
        values.put(PrevResultsEntry.COLUMN_NAME_ANALYSIS_RESULT, analysis_result);

        // Insert the new row, returning the primary key value of the new row
        return db.insert(PrevResultsEntry.TABLE_NAME, null, values);
    }

    public List readEntryFromDB(long id) {
        SQLiteDatabase db = dbHelper.getReadableDatabase();

        // Define a projection that specifies which columns from the database
        // you will actually use after this query.
        String[] projection = {
                PrevResultsEntry._ID,
                PrevResultsEntry.COLUMN_NAME_DATE,
                PrevResultsEntry.COLUMN_NAME_ANALYSIS_TYPE,
                PrevResultsEntry.COLUMN_NAME_APPS_ANALYSED,
                PrevResultsEntry.COLUMN_NAME_ANALYSIS_RESULT
        };

        // Filter results WHERE "title" = 'My Title'
        String selection = PrevResultsEntry._ID + " = ?";
        String[] selectionArgs = { id + "" };

        Cursor cursor = db.query(
                PrevResultsEntry.TABLE_NAME,    // The table to query
                projection,                     // The array of columns to return (pass null to get all)
                selection,                      // The columns for the WHERE clause
                selectionArgs,                  // The values for the WHERE clause
                null,                  // don't group the rows
                null,                   // don't filter by row groups
                null                   // don't sort
        );

        List values = new ArrayList<PrevResultsValues>();
        while(cursor.moveToNext()) {
            PrevResultsValues val = new PrevResultsValues();
            val.id = cursor.getLong(cursor.getColumnIndexOrThrow(PrevResultsEntry._ID));
            val.date = cursor.getString(cursor.getColumnIndexOrThrow(PrevResultsEntry.COLUMN_NAME_DATE));
            val.analysis_type = cursor.getString(cursor.getColumnIndexOrThrow(PrevResultsEntry.COLUMN_NAME_ANALYSIS_TYPE));
            val.apps_analysed = cursor.getString(cursor.getColumnIndexOrThrow(PrevResultsEntry.COLUMN_NAME_APPS_ANALYSED));
            val.analysis_result = cursor.getString(cursor.getColumnIndexOrThrow(PrevResultsEntry.COLUMN_NAME_ANALYSIS_RESULT));

            values.add(val);
        }
        cursor.close();

        return values;
    }

    public List readAllFromDB() {
        SQLiteDatabase db = dbHelper.getReadableDatabase();

        // Define a projection that specifies which columns from the database
        // you will actually use after this query.
        String[] projection = {
                PrevResultsEntry._ID,
                PrevResultsEntry.COLUMN_NAME_DATE,
                PrevResultsEntry.COLUMN_NAME_ANALYSIS_TYPE,
                PrevResultsEntry.COLUMN_NAME_APPS_ANALYSED,
                PrevResultsEntry.COLUMN_NAME_ANALYSIS_RESULT
        };

        // How you want the results sorted in the resulting Cursor
        String sortOrder = PrevResultsEntry.COLUMN_NAME_DATE + " DESC";

        Cursor cursor = db.query(
                PrevResultsEntry.TABLE_NAME,    // The table to query
                projection,                     // The array of columns to return (pass null to get all)
                null,                  // don't filter the selection
                null,               // don't filter the selection
                null,                  // don't group the rows
                null,                   // don't filter by row groups
                sortOrder                       // The sort order
        );

        List values = new ArrayList<PrevResultsValues>();
        while(cursor.moveToNext()) {
            PrevResultsValues val = new PrevResultsValues();
            val.id = cursor.getLong(cursor.getColumnIndexOrThrow(PrevResultsEntry._ID));
            val.date = cursor.getString(cursor.getColumnIndexOrThrow(PrevResultsEntry.COLUMN_NAME_DATE));
            val.analysis_type = cursor.getString(cursor.getColumnIndexOrThrow(PrevResultsEntry.COLUMN_NAME_ANALYSIS_TYPE));
            val.apps_analysed = cursor.getString(cursor.getColumnIndexOrThrow(PrevResultsEntry.COLUMN_NAME_APPS_ANALYSED));
            val.analysis_result = cursor.getString(cursor.getColumnIndexOrThrow(PrevResultsEntry.COLUMN_NAME_ANALYSIS_RESULT));

            values.add(val);
        }
        cursor.close();

        return values;
    }

    public void dropDB() {
        SQLiteDatabase db = dbHelper.getReadableDatabase();
        db.execSQL(SQL_DELETE_ENTRIES);
    }

    public void createDB() {
        SQLiteDatabase db = dbHelper.getReadableDatabase();
        db.execSQL(SQL_CREATE_ENTRIES);
    }

    public void closeDB() {
        dbHelper.close();
    }
}
